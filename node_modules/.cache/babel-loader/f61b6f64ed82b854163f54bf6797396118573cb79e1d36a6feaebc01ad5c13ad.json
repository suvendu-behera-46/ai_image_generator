{"ast":null,"code":"'use strict';\n\nconst batch = require('it-batch');\n\n/**\n * @template T\n * @typedef {{ok:true, value:T}} Success\n */\n\n/**\n * @typedef {{ok:false, err:Error}} Failure\n */\n\n/**\n * Takes an (async) iterator that emits promise-returning functions,\n * invokes them in parallel and emits the results as they become available but\n * in the same order as the input\n *\n * @template T\n * @param {AsyncIterable<() => Promise<T>>|Iterable<() => Promise<T>>} source\n * @param {number} [size=1]\n * @returns {AsyncIterable<T>}\n */\nfunction parallelBatch(source) {\n  try {\n    let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    return async function* () {\n      for await (const tasks of batch(source, size)) {\n        /** @type {Promise<Success<T>|Failure>[]} */\n        const things = tasks.map(\n        /**\n         * @param {() => Promise<T>} p\n         */\n        p => {\n          return p().then(value => ({\n            ok: true,\n            value\n          }), err => ({\n            ok: false,\n            err\n          }));\n        });\n        for (let i = 0; i < things.length; i++) {\n          const result = await things[i];\n          if (result.ok) {\n            yield result.value;\n          } else {\n            throw result.err;\n          }\n        }\n      }\n    }();\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}\nmodule.exports = parallelBatch;","map":{"version":3,"names":["batch","require","parallelBatch","source","size","tasks","things","map","p","then","value","ok","err","i","length","result","module","exports"],"sources":["/Users/suvendubehera/Projects/BlockChain/ai_nft_generator/node_modules/it-parallel-batch/index.js"],"sourcesContent":["'use strict'\n\nconst batch = require('it-batch')\n\n/**\n * @template T\n * @typedef {{ok:true, value:T}} Success\n */\n\n/**\n * @typedef {{ok:false, err:Error}} Failure\n */\n\n/**\n * Takes an (async) iterator that emits promise-returning functions,\n * invokes them in parallel and emits the results as they become available but\n * in the same order as the input\n *\n * @template T\n * @param {AsyncIterable<() => Promise<T>>|Iterable<() => Promise<T>>} source\n * @param {number} [size=1]\n * @returns {AsyncIterable<T>}\n */\nasync function * parallelBatch (source, size = 1) {\n  for await (const tasks of batch(source, size)) {\n    /** @type {Promise<Success<T>|Failure>[]} */\n    const things = tasks.map(\n      /**\n       * @param {() => Promise<T>} p\n       */\n      p => {\n        return p().then(value => ({ ok: true, value }), err => ({ ok: false, err }))\n      })\n\n    for (let i = 0; i < things.length; i++) {\n      const result = await things[i]\n\n      if (result.ok) {\n        yield result.value\n      } else {\n        throw result.err\n      }\n    }\n  }\n}\n\nmodule.exports = parallelBatch\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,KAAK,GAAGC,OAAO,CAAC,UAAU,CAAC;;AAEjC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAiBC,aAAa,CAAEC,MAAM;EAAA;IAAA,IAAEC,IAAI,uEAAG,CAAC;IAAA,0BAAE;MAChD,WAAW,MAAMC,KAAK,IAAIL,KAAK,CAACG,MAAM,EAAEC,IAAI,CAAC,EAAE;QAC7C;QACA,MAAME,MAAM,GAAGD,KAAK,CAACE,GAAG;QACtB;AACN;AACA;QACMC,CAAC,IAAI;UACH,OAAOA,CAAC,EAAE,CAACC,IAAI,CAACC,KAAK,KAAK;YAAEC,EAAE,EAAE,IAAI;YAAED;UAAM,CAAC,CAAC,EAAEE,GAAG,KAAK;YAAED,EAAE,EAAE,KAAK;YAAEC;UAAI,CAAC,CAAC,CAAC;QAC9E,CAAC,CAAC;QAEJ,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,MAAM,CAACQ,MAAM,EAAED,CAAC,EAAE,EAAE;UACtC,MAAME,MAAM,GAAG,MAAMT,MAAM,CAACO,CAAC,CAAC;UAE9B,IAAIE,MAAM,CAACJ,EAAE,EAAE;YACb,MAAMI,MAAM,CAACL,KAAK;UACpB,CAAC,MAAM;YACL,MAAMK,MAAM,CAACH,GAAG;UAClB;QACF;MACF;IACF,CAAC;EAAA;IAAA;EAAA;AAAA;AAEDI,MAAM,CAACC,OAAO,GAAGf,aAAa"},"metadata":{},"sourceType":"script","externalDependencies":[]}