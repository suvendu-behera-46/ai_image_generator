{"ast":null,"code":"import { pack } from 'ipfs-car/pack';\nimport { CID } from 'multiformats/cid';\nimport * as Block from 'multiformats/block';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport * as dagCbor from '@ipld/dag-cbor';\nimport { Blob, FormData, Blockstore } from './platform.js';\nimport { toGatewayURL, GATEWAY } from './gateway.js';\nimport { BlockstoreCarReader } from './bs-car-reader.js';\n\n/**\n * @typedef {import('./gateway.js').GatewayURLOptions} EmbedOptions\n * @typedef {import('./lib/interface.js').TokenInput} TokenInput\n * @typedef {import('ipfs-car/blockstore').Blockstore} Blockstore\n */\n\n/**\n * @template T\n * @typedef {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} EncodedBlobUrl\n */\n\n/**\n * @template G\n * @typedef {import('./lib/interface.js').Encoded<G, [[Blob, Blob]]>} EncodedBlobBlob\n */\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @typedef {import('./lib/interface.js').Token<T>} TokenType\n */\n\n/**\n * @template {TokenInput} T\n * @implements {TokenType<T>}\n */\nexport class Token {\n  /**\n   * @param {import('./lib/interface.js').CIDString} ipnft\n   * @param {import('./lib/interface.js').EncodedURL} url\n   * @param {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} data\n   */\n  constructor(ipnft, url, data) {\n    /** @readonly */\n    this.ipnft = ipnft;\n    /** @readonly */\n    this.url = url;\n    /** @readonly */\n    this.data = data;\n    Object.defineProperties(this, {\n      ipnft: {\n        enumerable: true,\n        writable: false\n      },\n      url: {\n        enumerable: true,\n        writable: false\n      },\n      data: {\n        enumerable: false,\n        writable: false\n      }\n    });\n  }\n  /**\n   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\n   */\n  embed() {\n    return Token.embed(this);\n  }\n\n  /**\n   * @template {TokenInput} T\n   * @param {{data: import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}} token\n   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\n   */\n  static embed({\n    data\n  }) {\n    return embed(data, {\n      gateway: GATEWAY\n    });\n  }\n\n  /**\n   * Takes token input, encodes it as a DAG, wraps it in a CAR and creates a new\n   * Token instance from it. Where values are discovered `Blob` (or `File`)\n   * objects in the given input, they are replaced with IPFS URLs (an `ipfs://`\n   * prefixed CID with an optional path).\n   *\n   * @example\n   * ```js\n   * const cat = new File(['...'], 'cat.png')\n   * const kitty = new File(['...'], 'kitty.png')\n   * const { token, car } = await Token.encode({\n   *   name: 'hello'\n   *   image: cat\n   *   properties: {\n   *     extra: {\n   *       image: kitty\n   *     }\n   *   }\n   * })\n   * ```\n   *\n   * @template {TokenInput} T\n   * @param {T} input\n   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: import('./lib/interface.js').CarReader }>}\n   */\n  static async encode(input) {\n    const blockstore = new Blockstore();\n    const [blobs, meta] = mapTokenInputBlobs(input);\n    /** @type {EncodedBlobUrl<T>} */\n    const data = JSON.parse(JSON.stringify(meta));\n    /** @type {import('./lib/interface.js').Encoded<T, [[Blob, CID]]>} */\n    const dag = JSON.parse(JSON.stringify(meta));\n    for (const [dotPath, blob] of blobs.entries()) {\n      /** @type {string|undefined} */\n      // @ts-ignore blob may be a File!\n      const name = blob.name || 'blob';\n      /** @type {import('./platform.js').ReadableStream} */\n      let content;\n      // FIXME: should not be necessary to await arrayBuffer()!\n      // Node.js 20 hangs reading the stream (it never ends) but in\n      // older node versions and the browser it is fine to use blob.stream().\n      /* c8 ignore next 5 */\n      if (parseInt(globalThis.process?.versions?.node) > 18) {\n        content = new Uint8Array(await blob.arrayBuffer());\n      } else {\n        content = blob.stream();\n      }\n      const {\n        root: cid\n      } = await pack({\n        input: [{\n          path: name,\n          content\n        }],\n        blockstore,\n        wrapWithDirectory: true\n      });\n      const href = new URL(`ipfs://${cid}/${name}`);\n      const path = dotPath.split('.');\n      setIn(data, path, href);\n      setIn(dag, path, cid);\n    }\n    const {\n      root: metadataJsonCid\n    } = await pack({\n      input: [{\n        path: 'metadata.json',\n        content: JSON.stringify(data)\n      }],\n      blockstore,\n      wrapWithDirectory: false\n    });\n    const block = await Block.encode({\n      value: {\n        ...dag,\n        'metadata.json': metadataJsonCid,\n        type: 'nft'\n      },\n      codec: dagCbor,\n      hasher: sha256\n    });\n    await blockstore.put(block.cid, block.bytes);\n    return {\n      cid: block.cid,\n      token: new Token(block.cid.toString(), `ipfs://${block.cid}/metadata.json`, data),\n      car: new BlockstoreCarReader(1, [block.cid], blockstore)\n    };\n  }\n}\n\n/**\n * @template T\n * @param {EncodedBlobUrl<T>} input\n * @param {EmbedOptions} options\n * @returns {EncodedBlobUrl<T>}\n */\nexport const embed = (input, options) => mapWith(input, isURL, embedURL, options);\n\n/**\n * @template {TokenInput} T\n * @param {import('./lib/interface.js').EncodedToken<T>} value\n * @param {Set<string>} paths - Paths were to expect EncodedURLs\n * @returns {Token<T>}\n */\nexport const decode = ({\n  ipnft,\n  url,\n  data\n}, paths) => new Token(ipnft, url, mapWith(data, isEncodedURL, decodeURL, paths));\n\n/**\n * @param {any} value\n * @returns {value is URL}\n */\nconst isURL = value => value instanceof URL;\n\n/**\n * @template State\n * @param {State} state\n * @param {import('./lib/interface.js').EncodedURL} url\n * @returns {[State, URL]}\n */\nconst decodeURL = (state, url) => [state, new URL(url)];\n\n/**\n * @param {EmbedOptions} context\n * @param {URL} url\n * @returns {[EmbedOptions, URL]}\n */\nconst embedURL = (context, url) => [context, toGatewayURL(url, context)];\n\n/**\n * @param {any} value\n * @returns {value is object}\n */\nconst isObject = value => typeof value === 'object' && value != null;\n\n/**\n * @param {any} value\n * @param {Set<string>} assetPaths\n * @param {PropertyKey[]} path\n * @returns {value is import('./lib/interface.js').EncodedURL}\n */\nconst isEncodedURL = (value, assetPaths, path) => typeof value === 'string' && assetPaths.has(path.join('.'));\n\n/**\n * Takes token input and encodes it into\n * [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n * object where form field values are discovered `Blob` (or `File`) objects in\n * the given token and field keys are `.` joined paths where they were discoverd\n * in the token. Additionally encoded `FormData` will also have a field\n * named `meta` containing JSON serialized token with blobs and file values\n * `null` set to null (this allows backend to injest all of the files from\n * `multipart/form-data` request and update provided \"meta\" data with\n * corresponding file ipfs:// URLs)\n *\n * @example\n * ```js\n * const cat = new File([], 'cat.png')\n * const kitty = new File([], 'kitty.png')\n * const form = encode({\n *   name: 'hello'\n *   image: cat\n *   properties: {\n *     extra: {\n *       image: kitty\n *     }\n *   }\n * })\n * [...form.entries()] //>\n * // [\n * //   ['image', cat],\n * //   ['properties.extra.image', kitty],\n * //   ['meta', '{\"name\":\"hello\",image:null,\"properties\":{\"extra\":{\"kitty\": null}}}']\n * // ]\n * ```\n *\n * @template {TokenInput} T\n * @param {EncodedBlobBlob<T>} input\n * @returns {FormData}\n */\nexport const encode = input => {\n  const [map, meta] = mapValueWith(input, isBlob, encodeBlob, new Map(), []);\n  const form = new FormData();\n  for (const [k, v] of map.entries()) {\n    form.set(k, v);\n  }\n  form.set('meta', JSON.stringify(meta));\n  return form;\n};\n\n/**\n * @param {Map<string, Blob>} data\n * @param {Blob} blob\n * @param {PropertyKey[]} path\n * @returns {[Map<string, Blob>, void]}\n */\nconst encodeBlob = (data, blob, path) => {\n  data.set(path.join('.'), blob);\n  return [data, undefined];\n};\n\n/**\n * @param {any} value\n * @returns {value is Blob}\n */\nconst isBlob = value => value instanceof Blob;\n\n/**\n * @template {TokenInput} T\n * @param {EncodedBlobBlob<T>} input\n */\nconst mapTokenInputBlobs = input => {\n  return mapValueWith(input, isBlob, encodeBlob, new Map(), []);\n};\n\n/**\n * Substitues values in the given `input` that match `p(value) == true` with\n * `f(value, context, path)` where `context` is whatever you pass (usually\n * a mutable state) and `path` is a array of keys / indexes where the value\n * was encountered.\n *\n * @template T, I, X, O, State\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * likey you'll start with `[]`.\n * @returns {import('./lib/interface.js').Encoded<T, [[I, O]]>}\n */\nexport const mapWith = (input, p, f, state) => {\n  const [, output] = mapValueWith(input, p, f, state, []);\n  return output;\n};\n\n/**\n * @template T, I, X, O, State\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * @param {PropertyKey[]} path - Path where the value was encountered. Most\n * likey you'll start with `[]`.\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapValueWith = (input, p, f, state, path) => p(input, state, path) ? f(state, input, path) : Array.isArray(input) ? mapArrayWith(input, p, f, state, path) : isObject(input) ? mapObjectWith(input, p, f, state, path) : [state, ( /** @type {any} */input)];\n\n/**\n * Just like `mapWith` except\n *\n * @template State, T, I, X, O\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapObjectWith = (input, p, f, init, path) => {\n  let state = init;\n  const output = /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */{};\n  for (const [key, value] of Object.entries(input)) {\n    const [next, out] = mapValueWith(value, p, f, state, [...path, key]);\n    // @ts-ignore\n    output[key] = out;\n    state = next;\n  }\n  return [state, output];\n};\n\n/**\n * Just like `mapWith` except for Arrays.\n *\n * @template I, X, O, State\n * @template {any[]} T\n * @param {T} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapArrayWith = (input, p, f, init, path) => {\n  const output = /** @type {unknown[]} */[];\n  let state = init;\n  for (const [index, element] of input.entries()) {\n    const [next, out] = mapValueWith(element, p, f, state, [...path, index]);\n    output[index] = out;\n    state = next;\n  }\n  return [state, ( /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */output)];\n};\n\n/**\n * Sets a given `value` at the given `path` on a passed `object`.\n *\n * @example\n * ```js\n * const obj = { a: { b: { c: 1 }}}\n * setIn(obj, ['a', 'b', 'c'], 5)\n * obj.a.b.c //> 5\n * ```\n *\n * @template V\n * @param {any} object\n * @param {string[]} path\n * @param {V} value\n */\nconst setIn = (object, path, value) => {\n  const n = path.length - 1;\n  let target = object;\n  for (let [index, key] of path.entries()) {\n    if (index === n) {\n      target[key] = value;\n    } else {\n      target = target[key];\n    }\n  }\n};","map":{"version":3,"names":["pack","CID","Block","sha256","dagCbor","Blob","FormData","Blockstore","toGatewayURL","GATEWAY","BlockstoreCarReader","Token","constructor","ipnft","url","data","Object","defineProperties","enumerable","writable","embed","gateway","encode","input","blockstore","blobs","meta","mapTokenInputBlobs","JSON","parse","stringify","dag","dotPath","blob","entries","name","content","parseInt","globalThis","process","versions","node","Uint8Array","arrayBuffer","stream","root","cid","path","wrapWithDirectory","href","URL","split","setIn","metadataJsonCid","block","value","type","codec","hasher","put","bytes","token","toString","car","options","mapWith","isURL","embedURL","decode","paths","isEncodedURL","decodeURL","state","context","isObject","assetPaths","has","join","map","mapValueWith","isBlob","encodeBlob","Map","form","k","v","set","undefined","p","f","output","Array","isArray","mapArrayWith","mapObjectWith","init","key","next","out","index","element","object","n","length","target"],"sources":["/Users/suvendubehera/Projects/BlockChain/ai_image_generator/node_modules/nft.storage/src/token.js"],"sourcesContent":["import { pack } from 'ipfs-car/pack'\nimport { CID } from 'multiformats/cid'\nimport * as Block from 'multiformats/block'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport * as dagCbor from '@ipld/dag-cbor'\nimport { Blob, FormData, Blockstore } from './platform.js'\nimport { toGatewayURL, GATEWAY } from './gateway.js'\nimport { BlockstoreCarReader } from './bs-car-reader.js'\n\n/**\n * @typedef {import('./gateway.js').GatewayURLOptions} EmbedOptions\n * @typedef {import('./lib/interface.js').TokenInput} TokenInput\n * @typedef {import('ipfs-car/blockstore').Blockstore} Blockstore\n */\n\n/**\n * @template T\n * @typedef {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} EncodedBlobUrl\n */\n\n/**\n * @template G\n * @typedef {import('./lib/interface.js').Encoded<G, [[Blob, Blob]]>} EncodedBlobBlob\n */\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @typedef {import('./lib/interface.js').Token<T>} TokenType\n */\n\n/**\n * @template {TokenInput} T\n * @implements {TokenType<T>}\n */\nexport class Token {\n  /**\n   * @param {import('./lib/interface.js').CIDString} ipnft\n   * @param {import('./lib/interface.js').EncodedURL} url\n   * @param {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} data\n   */\n  constructor(ipnft, url, data) {\n    /** @readonly */\n    this.ipnft = ipnft\n    /** @readonly */\n    this.url = url\n    /** @readonly */\n    this.data = data\n\n    Object.defineProperties(this, {\n      ipnft: { enumerable: true, writable: false },\n      url: { enumerable: true, writable: false },\n      data: { enumerable: false, writable: false },\n    })\n  }\n  /**\n   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\n   */\n  embed() {\n    return Token.embed(this)\n  }\n\n  /**\n   * @template {TokenInput} T\n   * @param {{data: import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}} token\n   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\n   */\n  static embed({ data }) {\n    return embed(data, { gateway: GATEWAY })\n  }\n\n  /**\n   * Takes token input, encodes it as a DAG, wraps it in a CAR and creates a new\n   * Token instance from it. Where values are discovered `Blob` (or `File`)\n   * objects in the given input, they are replaced with IPFS URLs (an `ipfs://`\n   * prefixed CID with an optional path).\n   *\n   * @example\n   * ```js\n   * const cat = new File(['...'], 'cat.png')\n   * const kitty = new File(['...'], 'kitty.png')\n   * const { token, car } = await Token.encode({\n   *   name: 'hello'\n   *   image: cat\n   *   properties: {\n   *     extra: {\n   *       image: kitty\n   *     }\n   *   }\n   * })\n   * ```\n   *\n   * @template {TokenInput} T\n   * @param {T} input\n   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: import('./lib/interface.js').CarReader }>}\n   */\n  static async encode(input) {\n    const blockstore = new Blockstore()\n    const [blobs, meta] = mapTokenInputBlobs(input)\n    /** @type {EncodedBlobUrl<T>} */\n    const data = JSON.parse(JSON.stringify(meta))\n    /** @type {import('./lib/interface.js').Encoded<T, [[Blob, CID]]>} */\n    const dag = JSON.parse(JSON.stringify(meta))\n\n    for (const [dotPath, blob] of blobs.entries()) {\n      /** @type {string|undefined} */\n      // @ts-ignore blob may be a File!\n      const name = blob.name || 'blob'\n      /** @type {import('./platform.js').ReadableStream} */\n      let content\n      // FIXME: should not be necessary to await arrayBuffer()!\n      // Node.js 20 hangs reading the stream (it never ends) but in\n      // older node versions and the browser it is fine to use blob.stream().\n      /* c8 ignore next 5 */\n      if (parseInt(globalThis.process?.versions?.node) > 18) {\n        content = new Uint8Array(await blob.arrayBuffer())\n      } else {\n        content = blob.stream()\n      }\n      const { root: cid } = await pack({\n        input: [{ path: name, content }],\n        blockstore,\n        wrapWithDirectory: true,\n      })\n\n      const href = new URL(`ipfs://${cid}/${name}`)\n      const path = dotPath.split('.')\n      setIn(data, path, href)\n      setIn(dag, path, cid)\n    }\n\n    const { root: metadataJsonCid } = await pack({\n      input: [{ path: 'metadata.json', content: JSON.stringify(data) }],\n      blockstore,\n      wrapWithDirectory: false,\n    })\n\n    const block = await Block.encode({\n      value: {\n        ...dag,\n        'metadata.json': metadataJsonCid,\n        type: 'nft',\n      },\n      codec: dagCbor,\n      hasher: sha256,\n    })\n    await blockstore.put(block.cid, block.bytes)\n\n    return {\n      cid: block.cid,\n      token: new Token(\n        block.cid.toString(),\n        `ipfs://${block.cid}/metadata.json`,\n        data\n      ),\n      car: new BlockstoreCarReader(1, [block.cid], blockstore),\n    }\n  }\n}\n\n/**\n * @template T\n * @param {EncodedBlobUrl<T>} input\n * @param {EmbedOptions} options\n * @returns {EncodedBlobUrl<T>}\n */\nexport const embed = (input, options) =>\n  mapWith(input, isURL, embedURL, options)\n\n/**\n * @template {TokenInput} T\n * @param {import('./lib/interface.js').EncodedToken<T>} value\n * @param {Set<string>} paths - Paths were to expect EncodedURLs\n * @returns {Token<T>}\n */\nexport const decode = ({ ipnft, url, data }, paths) =>\n  new Token(ipnft, url, mapWith(data, isEncodedURL, decodeURL, paths))\n\n/**\n * @param {any} value\n * @returns {value is URL}\n */\nconst isURL = (value) => value instanceof URL\n\n/**\n * @template State\n * @param {State} state\n * @param {import('./lib/interface.js').EncodedURL} url\n * @returns {[State, URL]}\n */\nconst decodeURL = (state, url) => [state, new URL(url)]\n\n/**\n * @param {EmbedOptions} context\n * @param {URL} url\n * @returns {[EmbedOptions, URL]}\n */\nconst embedURL = (context, url) => [context, toGatewayURL(url, context)]\n\n/**\n * @param {any} value\n * @returns {value is object}\n */\nconst isObject = (value) => typeof value === 'object' && value != null\n\n/**\n * @param {any} value\n * @param {Set<string>} assetPaths\n * @param {PropertyKey[]} path\n * @returns {value is import('./lib/interface.js').EncodedURL}\n */\nconst isEncodedURL = (value, assetPaths, path) =>\n  typeof value === 'string' && assetPaths.has(path.join('.'))\n\n/**\n * Takes token input and encodes it into\n * [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n * object where form field values are discovered `Blob` (or `File`) objects in\n * the given token and field keys are `.` joined paths where they were discoverd\n * in the token. Additionally encoded `FormData` will also have a field\n * named `meta` containing JSON serialized token with blobs and file values\n * `null` set to null (this allows backend to injest all of the files from\n * `multipart/form-data` request and update provided \"meta\" data with\n * corresponding file ipfs:// URLs)\n *\n * @example\n * ```js\n * const cat = new File([], 'cat.png')\n * const kitty = new File([], 'kitty.png')\n * const form = encode({\n *   name: 'hello'\n *   image: cat\n *   properties: {\n *     extra: {\n *       image: kitty\n *     }\n *   }\n * })\n * [...form.entries()] //>\n * // [\n * //   ['image', cat],\n * //   ['properties.extra.image', kitty],\n * //   ['meta', '{\"name\":\"hello\",image:null,\"properties\":{\"extra\":{\"kitty\": null}}}']\n * // ]\n * ```\n *\n * @template {TokenInput} T\n * @param {EncodedBlobBlob<T>} input\n * @returns {FormData}\n */\nexport const encode = (input) => {\n  const [map, meta] = mapValueWith(input, isBlob, encodeBlob, new Map(), [])\n  const form = new FormData()\n  for (const [k, v] of map.entries()) {\n    form.set(k, v)\n  }\n  form.set('meta', JSON.stringify(meta))\n  return form\n}\n\n/**\n * @param {Map<string, Blob>} data\n * @param {Blob} blob\n * @param {PropertyKey[]} path\n * @returns {[Map<string, Blob>, void]}\n */\nconst encodeBlob = (data, blob, path) => {\n  data.set(path.join('.'), blob)\n  return [data, undefined]\n}\n\n/**\n * @param {any} value\n * @returns {value is Blob}\n */\nconst isBlob = (value) => value instanceof Blob\n\n/**\n * @template {TokenInput} T\n * @param {EncodedBlobBlob<T>} input\n */\nconst mapTokenInputBlobs = (input) => {\n  return mapValueWith(input, isBlob, encodeBlob, new Map(), [])\n}\n\n/**\n * Substitues values in the given `input` that match `p(value) == true` with\n * `f(value, context, path)` where `context` is whatever you pass (usually\n * a mutable state) and `path` is a array of keys / indexes where the value\n * was encountered.\n *\n * @template T, I, X, O, State\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * likey you'll start with `[]`.\n * @returns {import('./lib/interface.js').Encoded<T, [[I, O]]>}\n */\nexport const mapWith = (input, p, f, state) => {\n  const [, output] = mapValueWith(input, p, f, state, [])\n  return output\n}\n\n/**\n * @template T, I, X, O, State\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * @param {PropertyKey[]} path - Path where the value was encountered. Most\n * likey you'll start with `[]`.\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapValueWith = (input, p, f, state, path) =>\n  p(input, state, path)\n    ? f(state, input, path)\n    : Array.isArray(input)\n    ? mapArrayWith(input, p, f, state, path)\n    : isObject(input)\n    ? mapObjectWith(input, p, f, state, path)\n    : [state, /** @type {any} */ (input)]\n\n/**\n * Just like `mapWith` except\n *\n * @template State, T, I, X, O\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapObjectWith = (input, p, f, init, path) => {\n  let state = init\n  const output =\n    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */ ({})\n  for (const [key, value] of Object.entries(input)) {\n    const [next, out] = mapValueWith(value, p, f, state, [...path, key])\n    // @ts-ignore\n    output[key] = out\n    state = next\n  }\n  return [state, output]\n}\n\n/**\n * Just like `mapWith` except for Arrays.\n *\n * @template I, X, O, State\n * @template {any[]} T\n * @param {T} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapArrayWith = (input, p, f, init, path) => {\n  const output = /** @type {unknown[]} */ ([])\n\n  let state = init\n  for (const [index, element] of input.entries()) {\n    const [next, out] = mapValueWith(element, p, f, state, [...path, index])\n    output[index] = out\n    state = next\n  }\n\n  return [\n    state,\n    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */ (output),\n  ]\n}\n\n/**\n * Sets a given `value` at the given `path` on a passed `object`.\n *\n * @example\n * ```js\n * const obj = { a: { b: { c: 1 }}}\n * setIn(obj, ['a', 'b', 'c'], 5)\n * obj.a.b.c //> 5\n * ```\n *\n * @template V\n * @param {any} object\n * @param {string[]} path\n * @param {V} value\n */\nconst setIn = (object, path, value) => {\n  const n = path.length - 1\n  let target = object\n  for (let [index, key] of path.entries()) {\n    if (index === n) {\n      target[key] = value\n    } else {\n      target = target[key]\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}