{"ast":null,"code":"/**\n * A client library for the https://nft.storage/ service. It provides a convenient\n * interface for working with the [Raw HTTP API](https://nft.storage/#api-docs)\n * from a web browser or [Node.js](https://nodejs.org/) and comes bundled with\n * TS for out-of-the box type inference and better IntelliSense.\n *\n * @example\n * ```js\n * import { NFTStorage, File, Blob } from \"nft.storage\"\n * const client = new NFTStorage({ token: API_TOKEN })\n *\n * const cid = await client.storeBlob(new Blob(['hello world']))\n * ```\n * @module\n */\n\nimport { transform } from 'streaming-iterables';\nimport pRetry, { AbortError } from 'p-retry';\nimport { TreewalkCarSplitter } from 'carbites/treewalk';\nimport { pack } from 'ipfs-car/pack';\nimport { CID } from 'multiformats/cid';\nimport throttledQueue from 'throttled-queue';\nimport * as Token from './token.js';\nimport { fetch, File, Blob, FormData, Blockstore } from './platform.js';\nimport { toGatewayURL } from './gateway.js';\nimport { BlockstoreCarReader } from './bs-car-reader.js';\nimport pipe from 'it-pipe';\nconst MAX_STORE_RETRIES = 5;\nconst MAX_CONCURRENT_UPLOADS = 3;\nconst MAX_CHUNK_SIZE = 1024 * 1024 * 50; // chunk to ~50MB CARs\nconst RATE_LIMIT_REQUESTS = 30;\nconst RATE_LIMIT_PERIOD = 10 * 1000;\n\n/**\n * @typedef {import('./lib/interface.js').Service} Service\n * @typedef {import('./lib/interface.js').CIDString} CIDString\n * @typedef {import('./lib/interface.js').Deal} Deal\n * @typedef {import('./lib/interface.js').FileObject} FileObject\n * @typedef {import('./lib/interface.js').FilesSource} FilesSource\n * @typedef {import('./lib/interface.js').Pin} Pin\n * @typedef {import('./lib/interface.js').CarReader} CarReader\n * @typedef {import('ipfs-car/blockstore').Blockstore} BlockstoreI\n * @typedef {import('./lib/interface.js').RateLimiter} RateLimiter\n * @typedef {import('./lib/interface.js').RequestOptions} RequestOptions\n */\n\n/**\n * @returns {RateLimiter}\n */\nexport function createRateLimiter() {\n  const throttle = throttledQueue(RATE_LIMIT_REQUESTS, RATE_LIMIT_PERIOD);\n  return () => throttle(() => {});\n}\n\n/**\n * Rate limiter used by static API if no rate limiter is passed. Note that each\n * instance of the NFTStorage class gets it's own limiter if none is passed.\n * This is because rate limits are enforced per API token.\n */\nconst globalRateLimiter = createRateLimiter();\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @typedef {import('./lib/interface.js').Token<T>} TokenType\n */\n\n/**\n * @implements {Service}\n */\nclass NFTStorage {\n  /**\n   * Constructs a client bound to the given `options.token` and\n   * `options.endpoint`.\n   *\n   * @example\n   * ```js\n   * import { NFTStorage, File, Blob } from \"nft.storage\"\n   * const client = new NFTStorage({ token: API_TOKEN })\n   *\n   * const cid = await client.storeBlob(new Blob(['hello world']))\n   * ```\n   * Optionally you could pass an alternative API endpoint (e.g. for testing)\n   * @example\n   * ```js\n   * import { NFTStorage } from \"nft.storage\"\n   * const client = new NFTStorage({\n   *   token: API_TOKEN\n   *   endpoint: new URL('http://localhost:8080/')\n   * })\n   * ```\n   *\n   * @param {{token: string, endpoint?: URL, rateLimiter?: RateLimiter, did?: string}} options\n   */\n  constructor({\n    token,\n    did,\n    endpoint = new URL('https://api.nft.storage'),\n    rateLimiter\n  }) {\n    /**\n     * Authorization token.\n     *\n     * @readonly\n     */\n    this.token = token;\n    /**\n     * Service API endpoint `URL`.\n     * @readonly\n     */\n    this.endpoint = endpoint;\n    /**\n     * @readonly\n     */\n    this.rateLimiter = rateLimiter || createRateLimiter();\n\n    /**\n     * @readonly\n     */\n    this.did = did;\n  }\n\n  /**\n   * @hidden\n   * @param {object} options\n   * @param {string} options.token\n   * @param {string} [options.did]\n   */\n  static auth({\n    token,\n    did\n  }) {\n    if (!token) throw new Error('missing token');\n    return {\n      Authorization: `Bearer ${token}`,\n      'X-Client': 'nft.storage/js',\n      ...(did ? {\n        'x-agent-did': did\n      } : {})\n    };\n  }\n\n  /**\n   * Stores a single file and returns its CID.\n   *\n   * @param {Service} service\n   * @param {Blob} blob\n   * @param {RequestOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async storeBlob(service, blob, options) {\n    const blockstore = new Blockstore();\n    let cidString;\n    try {\n      const {\n        cid,\n        car\n      } = await NFTStorage.encodeBlob(blob, {\n        blockstore\n      });\n      await NFTStorage.storeCar(service, car, options);\n      cidString = cid.toString();\n    } finally {\n      await blockstore.close();\n    }\n    return cidString;\n  }\n\n  /**\n   * Stores a CAR file and returns its root CID.\n   *\n   * @param {Service} service\n   * @param {Blob|CarReader} car\n   * @param {import('./lib/interface.js').CarStorerOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async storeCar({\n    endpoint,\n    rateLimiter = globalRateLimiter,\n    ...token\n  }, car, {\n    onStoredChunk,\n    maxRetries,\n    maxChunkSize,\n    decoders,\n    signal\n  } = {}) {\n    const url = new URL('upload/', endpoint);\n    const headers = {\n      ...NFTStorage.auth(token),\n      'Content-Type': 'application/car'\n    };\n    const targetSize = maxChunkSize || MAX_CHUNK_SIZE;\n    const splitter = car instanceof Blob ? await TreewalkCarSplitter.fromBlob(car, targetSize, {\n      decoders\n    }) : new TreewalkCarSplitter(car, targetSize, {\n      decoders\n    });\n    const upload = transform(MAX_CONCURRENT_UPLOADS, async function ( /** @type {AsyncIterable<Uint8Array>} */car) {\n      const carParts = [];\n      for await (const part of car) {\n        carParts.push(part);\n      }\n      const carFile = new Blob(carParts, {\n        type: 'application/car'\n      });\n      /** @type {Blob|ArrayBuffer} */\n      let body = carFile;\n      // FIXME: should not be necessary to await arrayBuffer()!\n      // Node.js 20 hangs reading the stream (it never ends) but in\n      // older node versions and the browser it is fine to pass a blob.\n      /* c8 ignore next 3 */\n      if (parseInt(globalThis.process?.versions?.node) > 18) {\n        body = await body.arrayBuffer();\n      }\n      const cid = await pRetry(async () => {\n        await rateLimiter();\n        /** @type {Response} */\n        let response;\n        try {\n          response = await fetch(url.toString(), {\n            method: 'POST',\n            headers,\n            body,\n            signal\n          });\n        } catch ( /** @type {any} */err) {\n          // TODO: remove me and test when client accepts custom fetch impl\n          /* c8 ignore next 1 */\n          throw signal && signal.aborted ? new AbortError(err) : err;\n        }\n        /* c8 ignore next 3 */\n        if (response.status === 429) {\n          throw new Error('rate limited');\n        }\n        const result = await response.json();\n        if (!result.ok) {\n          // do not retry if unauthorized - will not succeed\n          if (response.status === 401) {\n            throw new AbortError(result.error.message);\n          }\n          throw new Error(result.error.message);\n        }\n        return result.value.cid;\n      }, {\n        retries: maxRetries == null ? MAX_STORE_RETRIES : maxRetries\n      });\n      onStoredChunk && onStoredChunk(carFile.size);\n      return cid;\n    });\n    let root;\n    for await (const cid of upload(splitter.cars())) {\n      root = cid;\n    }\n    return /** @type {CIDString} */root;\n  }\n\n  /**\n   * Stores a directory of files and returns a CID. Provided files **MUST**\n   * be within the same directory, otherwise error is raised e.g. `foo/bar.png`,\n   * `foo/bla/baz.json` is ok but `foo/bar.png`, `bla/baz.json` is not.\n   *\n   * @param {Service} service\n   * @param {FilesSource} filesSource\n   * @param {RequestOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async storeDirectory(service, filesSource, options) {\n    const blockstore = new Blockstore();\n    let cidString;\n    try {\n      const {\n        cid,\n        car\n      } = await NFTStorage.encodeDirectory(filesSource, {\n        blockstore\n      });\n      await NFTStorage.storeCar(service, car, options);\n      cidString = cid.toString();\n    } finally {\n      await blockstore.close();\n    }\n    return cidString;\n  }\n\n  /**\n   * Stores the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in ERC-1155. The\n   * `token.image` must be either a `File` or a `Blob` instance, which will be\n   * stored and the corresponding content address URL will be saved in the\n   * metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {Service} service\n   * @param {T} metadata\n   * @param {RequestOptions} [options]\n   * @returns {Promise<TokenType<T>>}\n   */\n  static async store(service, metadata, options) {\n    const {\n      token,\n      car\n    } = await NFTStorage.encodeNFT(metadata);\n    await NFTStorage.storeCar(service, car, options);\n    return token;\n  }\n\n  /**\n   * Returns current status of the stored NFT by its CID. Note the NFT must\n   * have previously been stored by this account.\n   *\n   * @param {Service} service\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<import('./lib/interface.js').StatusResult>}\n   */\n  static async status({\n    endpoint,\n    rateLimiter = globalRateLimiter,\n    ...token\n  }, cid, options) {\n    const url = new URL(`${cid}/`, endpoint);\n    await rateLimiter();\n    const response = await fetch(url.toString(), {\n      method: 'GET',\n      headers: NFTStorage.auth(token),\n      signal: options && options.signal\n    });\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited');\n    }\n    const result = await response.json();\n    if (result.ok) {\n      return {\n        cid: result.value.cid,\n        deals: decodeDeals(result.value.deals),\n        size: result.value.size,\n        pin: decodePin(result.value.pin),\n        created: new Date(result.value.created)\n      };\n    } else {\n      throw new Error(result.error.message);\n    }\n  }\n\n  /**\n   * Check if a CID of an NFT is being stored by NFT.Storage.\n   *\n   * @param {import('./lib/interface.js').PublicService} service\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<import('./lib/interface.js').CheckResult>}\n   */\n  static async check({\n    endpoint,\n    rateLimiter = globalRateLimiter\n  }, cid, options) {\n    const url = new URL(`check/${cid}/`, endpoint);\n    await rateLimiter();\n    const response = await fetch(url.toString(), {\n      signal: options && options.signal\n    });\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited');\n    }\n    const result = await response.json();\n    if (result.ok) {\n      return {\n        cid: result.value.cid,\n        deals: decodeDeals(result.value.deals),\n        pin: result.value.pin\n      };\n    } else {\n      throw new Error(result.error.message);\n    }\n  }\n\n  /**\n   * Removes stored content by its CID from this account. Please note that\n   * even if content is removed from the service other nodes that have\n   * replicated it might still continue providing it.\n   *\n   * @param {Service} service\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<void>}\n   */\n  static async delete({\n    endpoint,\n    rateLimiter = globalRateLimiter,\n    ...token\n  }, cid, options) {\n    const url = new URL(`${cid}/`, endpoint);\n    await rateLimiter();\n    const response = await fetch(url.toString(), {\n      method: 'DELETE',\n      headers: NFTStorage.auth(token),\n      signal: options && options.signal\n    });\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited');\n    }\n    const result = await response.json();\n    if (!result.ok) {\n      throw new Error(result.error.message);\n    }\n  }\n\n  /**\n   * Encodes the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in ERC-1155 to a\n   * CAR file. The `token.image` must be either a `File` or a `Blob` instance,\n   * which will be stored and the corresponding content address URL will be\n   * saved in the metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @example\n   * ```js\n   * const { token, car } = await NFTStorage.encodeNFT({\n   *   name: 'nft.storage store test',\n   *   description: 'Test ERC-1155 compatible metadata.',\n   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),\n   *   properties: {\n   *     custom: 'Custom data can appear here, files are auto uploaded.',\n   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),\n   *   }\n   * })\n   *\n   * console.log('IPFS URL for the metadata:', token.url)\n   * console.log('metadata.json contents:\\n', token.data)\n   * console.log('metadata.json with IPFS gateway URLs:\\n', token.embed())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {T} input\n   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: CarReader }>}\n   */\n  static async encodeNFT(input) {\n    validateERC1155(input);\n    return Token.Token.encode(input);\n  }\n\n  /**\n   * Encodes a single file to a CAR file and also returns its root CID.\n   *\n   * @example\n   * ```js\n   * const content = new Blob(['hello world'])\n   * const { cid, car } = await NFTStorage.encodeBlob(content)\n   *\n   * // Root CID of the file\n   * console.log(cid.toString())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @param {Blob} blob\n   * @param {object} [options]\n   * @param {BlockstoreI} [options.blockstore]\n   * @returns {Promise<{ cid: CID, car: CarReader }>}\n   */\n  static async encodeBlob(blob, {\n    blockstore\n  } = {}) {\n    if (blob.size === 0) {\n      throw new Error('Content size is 0, make sure to provide some content');\n    }\n    return packCar([toImportCandidate('blob', blob)], {\n      blockstore,\n      wrapWithDirectory: false\n    });\n  }\n\n  /**\n   * Encodes a directory of files to a CAR file and also returns the root CID.\n   * Provided files **MUST** be within the same directory, otherwise error is\n   * raised e.g. `foo/bar.png`, `foo/bla/baz.json` is ok but `foo/bar.png`,\n   * `bla/baz.json` is not.\n   *\n   * @example\n   * ```js\n   * const { cid, car } = await NFTStorage.encodeDirectory([\n   *   new File(['hello world'], 'hello.txt'),\n   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')\n   * ])\n   *\n   * // Root CID of the directory\n   * console.log(cid.toString())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @param {FilesSource} files\n   * @param {object} [options]\n   * @param {BlockstoreI} [options.blockstore]\n   * @returns {Promise<{ cid: CID, car: CarReader }>}\n   */\n  static async encodeDirectory(files, {\n    blockstore\n  } = {}) {\n    let size = 0;\n    const input = pipe(files, async function* (files) {\n      for await (const file of files) {\n        yield toImportCandidate(file.name, file);\n        size += file.size;\n      }\n    });\n    const packed = await packCar(input, {\n      blockstore,\n      wrapWithDirectory: true\n    });\n    if (size === 0) {\n      throw new Error('Total size of files should exceed 0, make sure to provide some content');\n    }\n    return packed;\n  }\n\n  // Just a sugar so you don't have to pass around endpoint and token around.\n\n  /**\n   * Stores a single file and returns the corresponding Content Identifier (CID).\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File). Note\n   * that no file name or file metadata is retained.\n   *\n   * @example\n   * ```js\n   * const content = new Blob(['hello world'])\n   * const cid = await client.storeBlob(content)\n   * cid //> 'zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9'\n   * ```\n   *\n   * @param {Blob} blob\n   * @param {RequestOptions} [options]\n   */\n  storeBlob(blob, options) {\n    return NFTStorage.storeBlob(this, blob, options);\n  }\n\n  /**\n   * Stores files encoded as a single [Content Addressed Archive\n   * (CAR)](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md).\n   *\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File).\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * See the [`ipfs-car` docs](https://www.npmjs.com/package/ipfs-car) for more\n   * details on packing a CAR file.\n   *\n   * @example\n   * ```js\n   * import { pack } from 'ipfs-car/pack'\n   * import { CarReader } from '@ipld/car'\n   * const { out, root } = await pack({\n   *  input: fs.createReadStream('pinpie.pdf')\n   * })\n   * const expectedCid = root.toString()\n   * const carReader = await CarReader.fromIterable(out)\n   * const cid = await storage.storeCar(carReader)\n   * console.assert(cid === expectedCid)\n   * ```\n   *\n   * @example\n   * ```\n   * import { packToBlob } from 'ipfs-car/pack/blob'\n   * const data = 'Hello world'\n   * const { root, car } = await packToBlob({ input: [new TextEncoder().encode(data)] })\n   * const expectedCid = root.toString()\n   * const cid = await client.storeCar(car)\n   * console.assert(cid === expectedCid)\n   * ```\n   * @param {Blob|CarReader} car\n   * @param {import('./lib/interface.js').CarStorerOptions} [options]\n   */\n  storeCar(car, options) {\n    return NFTStorage.storeCar(this, car, options);\n  }\n\n  /**\n   * Stores a directory of files and returns a CID for the directory.\n   *\n   * @example\n   * ```js\n   * const cid = await client.storeDirectory([\n   *   new File(['hello world'], 'hello.txt'),\n   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')\n   * ])\n   * cid //>\n   * ```\n   *\n   * Argument can be a [FileList](https://developer.mozilla.org/en-US/docs/Web/API/FileList)\n   * instance as well, in which case directory structure will be retained.\n   *\n   * @param {FilesSource} files\n   * @param {RequestOptions} [options]\n   */\n  storeDirectory(files, options) {\n    return NFTStorage.storeDirectory(this, files, options);\n  }\n\n  /**\n   * Returns current status of the stored NFT by its CID. Note the NFT must\n   * have previously been stored by this account.\n   *\n   * @example\n   * ```js\n   * const status = await client.status('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   */\n  status(cid, options) {\n    return NFTStorage.status(this, cid, options);\n  }\n\n  /**\n   * Removes stored content by its CID from the service.\n   *\n   * > Please note that even if content is removed from the service other nodes\n   * that have replicated it might still continue providing it.\n   *\n   * @example\n   * ```js\n   * await client.delete('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   */\n  delete(cid, options) {\n    return NFTStorage.delete(this, cid, options);\n  }\n\n  /**\n   * Check if a CID of an NFT is being stored by nft.storage. Throws if the NFT\n   * was not found.\n   *\n   * @example\n   * ```js\n   * const status = await client.check('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   */\n  check(cid, options) {\n    return NFTStorage.check(this, cid, options);\n  }\n\n  /**\n   * Stores the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in\n   * [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155#metadata). The\n   * `token.image` must be either a `File` or a `Blob` instance, which will be\n   * stored and the corresponding content address URL will be saved in the\n   * metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @example\n   * ```js\n   * const metadata = await client.store({\n   *   name: 'nft.storage store test',\n   *   description: 'Test ERC-1155 compatible metadata.',\n   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),\n   *   properties: {\n   *     custom: 'Custom data can appear here, files are auto uploaded.',\n   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),\n   *   }\n   * })\n   *\n   * console.log('IPFS URL for the metadata:', metadata.url)\n   * console.log('metadata.json contents:\\n', metadata.data)\n   * console.log('metadata.json with IPFS gateway URLs:\\n', metadata.embed())\n   * ```\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {T} token\n   * @param {RequestOptions} [options]\n   */\n  store(token, options) {\n    return NFTStorage.store(this, token, options);\n  }\n}\n\n/**\n * Cast an iterable to an asyncIterable\n * @template T\n * @param {Iterable<T>} iterable\n * @returns {AsyncIterable<T>}\n */\nexport function toAsyncIterable(iterable) {\n  return async function* () {\n    for (const item of iterable) {\n      yield item;\n    }\n  }();\n}\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @param {T} metadata\n */\nconst validateERC1155 = ({\n  name,\n  description,\n  image,\n  decimals\n}) => {\n  // Just validate that expected fields are present\n  if (typeof name !== 'string') {\n    throw new TypeError('string property `name` identifying the asset is required');\n  }\n  if (typeof description !== 'string') {\n    throw new TypeError('string property `description` describing asset is required');\n  }\n  if (!(image instanceof Blob)) {\n    throw new TypeError('property `image` must be a Blob or File object');\n  } else if (!image.type.startsWith('image/')) {\n    console.warn(`According to ERC721 Metadata JSON Schema 'image' must have 'image/*' mime type.\n\nFor better interoperability we would highly recommend storing content with different mime type under 'properties' namespace e.g. \\`properties: { video: file }\\` and using 'image' field for storing a preview image for it instead.\n\nFor more context please see ERC-721 specification https://eips.ethereum.org/EIPS/eip-721`);\n  }\n  if (typeof decimals !== 'undefined' && typeof decimals !== 'number') {\n    throw new TypeError('property `decimals` must be an integer value');\n  }\n};\n\n/**\n * @param {import('ipfs-car/pack').ImportCandidateStream|Array<{ path: string, content: import('./platform.js').ReadableStream }>} input\n * @param {object} [options]\n * @param {BlockstoreI} [options.blockstore]\n * @param {boolean} [options.wrapWithDirectory]\n */\nconst packCar = async (input, {\n  blockstore,\n  wrapWithDirectory\n} = {}) => {\n  /* c8 ignore next 1 */\n  blockstore = blockstore || new Blockstore();\n  const {\n    root: cid\n  } = await pack({\n    input,\n    blockstore,\n    wrapWithDirectory\n  });\n  const car = new BlockstoreCarReader(1, [cid], blockstore);\n  return {\n    cid,\n    car\n  };\n};\n\n/**\n * @param {Deal[]} deals\n * @returns {Deal[]}\n */\nconst decodeDeals = deals => deals.map(deal => {\n  const {\n    dealActivation,\n    dealExpiration,\n    lastChanged\n  } = {\n    dealExpiration: null,\n    dealActivation: null,\n    ...deal\n  };\n  return {\n    ...deal,\n    lastChanged: new Date(lastChanged),\n    ...(dealActivation && {\n      dealActivation: new Date(dealActivation)\n    }),\n    ...(dealExpiration && {\n      dealExpiration: new Date(dealExpiration)\n    })\n  };\n});\n\n/**\n * @param {Pin} pin\n * @returns {Pin}\n */\nconst decodePin = pin => ({\n  ...pin,\n  created: new Date(pin.created)\n});\n\n/**\n * Convert the passed blob to an \"import candidate\" - an object suitable for\n * passing to the ipfs-unixfs-importer. Note: content is an accessor so that\n * the stream is created only when needed.\n *\n * @param {string} path\n * @param {Pick<Blob, 'stream'>|{ stream: () => AsyncIterable<Uint8Array> }} blob\n * @returns {import('ipfs-core-types/src/utils.js').ImportCandidate}\n */\nfunction toImportCandidate(path, blob) {\n  /** @type {AsyncIterable<Uint8Array>} */\n  let stream;\n  return {\n    path,\n    get content() {\n      stream = stream || blob.stream();\n      return stream;\n    }\n  };\n}\nexport { NFTStorage, File, Blob, FormData, toGatewayURL, Token };","map":{"version":3,"names":["transform","pRetry","AbortError","TreewalkCarSplitter","pack","CID","throttledQueue","Token","fetch","File","Blob","FormData","Blockstore","toGatewayURL","BlockstoreCarReader","pipe","MAX_STORE_RETRIES","MAX_CONCURRENT_UPLOADS","MAX_CHUNK_SIZE","RATE_LIMIT_REQUESTS","RATE_LIMIT_PERIOD","createRateLimiter","throttle","globalRateLimiter","NFTStorage","constructor","token","did","endpoint","URL","rateLimiter","auth","Error","Authorization","storeBlob","service","blob","options","blockstore","cidString","cid","car","encodeBlob","storeCar","toString","close","onStoredChunk","maxRetries","maxChunkSize","decoders","signal","url","headers","targetSize","splitter","fromBlob","upload","carParts","part","push","carFile","type","body","parseInt","globalThis","process","versions","node","arrayBuffer","response","method","err","aborted","status","result","json","ok","error","message","value","retries","size","root","cars","storeDirectory","filesSource","encodeDirectory","store","metadata","encodeNFT","deals","decodeDeals","pin","decodePin","created","Date","check","delete","input","validateERC1155","encode","packCar","toImportCandidate","wrapWithDirectory","files","file","name","packed","toAsyncIterable","iterable","item","description","image","decimals","TypeError","startsWith","console","warn","map","deal","dealActivation","dealExpiration","lastChanged","path","stream","content"],"sources":["/Users/suvendubehera/Projects/BlockChain/ai_image_generator/node_modules/nft.storage/src/lib.js"],"sourcesContent":["/**\n * A client library for the https://nft.storage/ service. It provides a convenient\n * interface for working with the [Raw HTTP API](https://nft.storage/#api-docs)\n * from a web browser or [Node.js](https://nodejs.org/) and comes bundled with\n * TS for out-of-the box type inference and better IntelliSense.\n *\n * @example\n * ```js\n * import { NFTStorage, File, Blob } from \"nft.storage\"\n * const client = new NFTStorage({ token: API_TOKEN })\n *\n * const cid = await client.storeBlob(new Blob(['hello world']))\n * ```\n * @module\n */\n\nimport { transform } from 'streaming-iterables'\nimport pRetry, { AbortError } from 'p-retry'\nimport { TreewalkCarSplitter } from 'carbites/treewalk'\nimport { pack } from 'ipfs-car/pack'\nimport { CID } from 'multiformats/cid'\nimport throttledQueue from 'throttled-queue'\nimport * as Token from './token.js'\nimport { fetch, File, Blob, FormData, Blockstore } from './platform.js'\nimport { toGatewayURL } from './gateway.js'\nimport { BlockstoreCarReader } from './bs-car-reader.js'\nimport pipe from 'it-pipe'\n\nconst MAX_STORE_RETRIES = 5\nconst MAX_CONCURRENT_UPLOADS = 3\nconst MAX_CHUNK_SIZE = 1024 * 1024 * 50 // chunk to ~50MB CARs\nconst RATE_LIMIT_REQUESTS = 30\nconst RATE_LIMIT_PERIOD = 10 * 1000\n\n/**\n * @typedef {import('./lib/interface.js').Service} Service\n * @typedef {import('./lib/interface.js').CIDString} CIDString\n * @typedef {import('./lib/interface.js').Deal} Deal\n * @typedef {import('./lib/interface.js').FileObject} FileObject\n * @typedef {import('./lib/interface.js').FilesSource} FilesSource\n * @typedef {import('./lib/interface.js').Pin} Pin\n * @typedef {import('./lib/interface.js').CarReader} CarReader\n * @typedef {import('ipfs-car/blockstore').Blockstore} BlockstoreI\n * @typedef {import('./lib/interface.js').RateLimiter} RateLimiter\n * @typedef {import('./lib/interface.js').RequestOptions} RequestOptions\n */\n\n/**\n * @returns {RateLimiter}\n */\nexport function createRateLimiter() {\n  const throttle = throttledQueue(RATE_LIMIT_REQUESTS, RATE_LIMIT_PERIOD)\n  return () => throttle(() => {})\n}\n\n/**\n * Rate limiter used by static API if no rate limiter is passed. Note that each\n * instance of the NFTStorage class gets it's own limiter if none is passed.\n * This is because rate limits are enforced per API token.\n */\nconst globalRateLimiter = createRateLimiter()\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @typedef {import('./lib/interface.js').Token<T>} TokenType\n */\n\n/**\n * @implements {Service}\n */\nclass NFTStorage {\n  /**\n   * Constructs a client bound to the given `options.token` and\n   * `options.endpoint`.\n   *\n   * @example\n   * ```js\n   * import { NFTStorage, File, Blob } from \"nft.storage\"\n   * const client = new NFTStorage({ token: API_TOKEN })\n   *\n   * const cid = await client.storeBlob(new Blob(['hello world']))\n   * ```\n   * Optionally you could pass an alternative API endpoint (e.g. for testing)\n   * @example\n   * ```js\n   * import { NFTStorage } from \"nft.storage\"\n   * const client = new NFTStorage({\n   *   token: API_TOKEN\n   *   endpoint: new URL('http://localhost:8080/')\n   * })\n   * ```\n   *\n   * @param {{token: string, endpoint?: URL, rateLimiter?: RateLimiter, did?: string}} options\n   */\n  constructor({\n    token,\n    did,\n    endpoint = new URL('https://api.nft.storage'),\n    rateLimiter,\n  }) {\n    /**\n     * Authorization token.\n     *\n     * @readonly\n     */\n    this.token = token\n    /**\n     * Service API endpoint `URL`.\n     * @readonly\n     */\n    this.endpoint = endpoint\n    /**\n     * @readonly\n     */\n    this.rateLimiter = rateLimiter || createRateLimiter()\n\n    /**\n     * @readonly\n     */\n    this.did = did\n  }\n\n  /**\n   * @hidden\n   * @param {object} options\n   * @param {string} options.token\n   * @param {string} [options.did]\n   */\n  static auth({ token, did }) {\n    if (!token) throw new Error('missing token')\n    return {\n      Authorization: `Bearer ${token}`,\n      'X-Client': 'nft.storage/js',\n      ...(did ? { 'x-agent-did': did } : {}),\n    }\n  }\n\n  /**\n   * Stores a single file and returns its CID.\n   *\n   * @param {Service} service\n   * @param {Blob} blob\n   * @param {RequestOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async storeBlob(service, blob, options) {\n    const blockstore = new Blockstore()\n    let cidString\n\n    try {\n      const { cid, car } = await NFTStorage.encodeBlob(blob, { blockstore })\n      await NFTStorage.storeCar(service, car, options)\n      cidString = cid.toString()\n    } finally {\n      await blockstore.close()\n    }\n\n    return cidString\n  }\n\n  /**\n   * Stores a CAR file and returns its root CID.\n   *\n   * @param {Service} service\n   * @param {Blob|CarReader} car\n   * @param {import('./lib/interface.js').CarStorerOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async storeCar(\n    { endpoint, rateLimiter = globalRateLimiter, ...token },\n    car,\n    { onStoredChunk, maxRetries, maxChunkSize, decoders, signal } = {}\n  ) {\n    const url = new URL('upload/', endpoint)\n    const headers = {\n      ...NFTStorage.auth(token),\n      'Content-Type': 'application/car',\n    }\n    const targetSize = maxChunkSize || MAX_CHUNK_SIZE\n    const splitter =\n      car instanceof Blob\n        ? await TreewalkCarSplitter.fromBlob(car, targetSize, { decoders })\n        : new TreewalkCarSplitter(car, targetSize, { decoders })\n\n    const upload = transform(\n      MAX_CONCURRENT_UPLOADS,\n      async function (/** @type {AsyncIterable<Uint8Array>} */ car) {\n        const carParts = []\n        for await (const part of car) {\n          carParts.push(part)\n        }\n        const carFile = new Blob(carParts, { type: 'application/car' })\n        /** @type {Blob|ArrayBuffer} */\n        let body = carFile\n        // FIXME: should not be necessary to await arrayBuffer()!\n        // Node.js 20 hangs reading the stream (it never ends) but in\n        // older node versions and the browser it is fine to pass a blob.\n        /* c8 ignore next 3 */\n        if (parseInt(globalThis.process?.versions?.node) > 18) {\n          body = await body.arrayBuffer()\n        }\n        const cid = await pRetry(\n          async () => {\n            await rateLimiter()\n            /** @type {Response} */\n            let response\n            try {\n              response = await fetch(url.toString(), {\n                method: 'POST',\n                headers,\n                body,\n                signal,\n              })\n            } catch (/** @type {any} */ err) {\n              // TODO: remove me and test when client accepts custom fetch impl\n              /* c8 ignore next 1 */\n              throw signal && signal.aborted ? new AbortError(err) : err\n            }\n            /* c8 ignore next 3 */\n            if (response.status === 429) {\n              throw new Error('rate limited')\n            }\n            const result = await response.json()\n            if (!result.ok) {\n              // do not retry if unauthorized - will not succeed\n              if (response.status === 401) {\n                throw new AbortError(result.error.message)\n              }\n              throw new Error(result.error.message)\n            }\n            return result.value.cid\n          },\n          {\n            retries: maxRetries == null ? MAX_STORE_RETRIES : maxRetries,\n          }\n        )\n        onStoredChunk && onStoredChunk(carFile.size)\n        return cid\n      }\n    )\n\n    let root\n    for await (const cid of upload(splitter.cars())) {\n      root = cid\n    }\n\n    return /** @type {CIDString} */ (root)\n  }\n\n  /**\n   * Stores a directory of files and returns a CID. Provided files **MUST**\n   * be within the same directory, otherwise error is raised e.g. `foo/bar.png`,\n   * `foo/bla/baz.json` is ok but `foo/bar.png`, `bla/baz.json` is not.\n   *\n   * @param {Service} service\n   * @param {FilesSource} filesSource\n   * @param {RequestOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async storeDirectory(service, filesSource, options) {\n    const blockstore = new Blockstore()\n    let cidString\n    try {\n      const { cid, car } = await NFTStorage.encodeDirectory(filesSource, {\n        blockstore,\n      })\n      await NFTStorage.storeCar(service, car, options)\n      cidString = cid.toString()\n    } finally {\n      await blockstore.close()\n    }\n\n    return cidString\n  }\n\n  /**\n   * Stores the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in ERC-1155. The\n   * `token.image` must be either a `File` or a `Blob` instance, which will be\n   * stored and the corresponding content address URL will be saved in the\n   * metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {Service} service\n   * @param {T} metadata\n   * @param {RequestOptions} [options]\n   * @returns {Promise<TokenType<T>>}\n   */\n  static async store(service, metadata, options) {\n    const { token, car } = await NFTStorage.encodeNFT(metadata)\n    await NFTStorage.storeCar(service, car, options)\n    return token\n  }\n\n  /**\n   * Returns current status of the stored NFT by its CID. Note the NFT must\n   * have previously been stored by this account.\n   *\n   * @param {Service} service\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<import('./lib/interface.js').StatusResult>}\n   */\n  static async status(\n    { endpoint, rateLimiter = globalRateLimiter, ...token },\n    cid,\n    options\n  ) {\n    const url = new URL(`${cid}/`, endpoint)\n    await rateLimiter()\n    const response = await fetch(url.toString(), {\n      method: 'GET',\n      headers: NFTStorage.auth(token),\n      signal: options && options.signal,\n    })\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited')\n    }\n    const result = await response.json()\n\n    if (result.ok) {\n      return {\n        cid: result.value.cid,\n        deals: decodeDeals(result.value.deals),\n        size: result.value.size,\n        pin: decodePin(result.value.pin),\n        created: new Date(result.value.created),\n      }\n    } else {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * Check if a CID of an NFT is being stored by NFT.Storage.\n   *\n   * @param {import('./lib/interface.js').PublicService} service\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<import('./lib/interface.js').CheckResult>}\n   */\n  static async check(\n    { endpoint, rateLimiter = globalRateLimiter },\n    cid,\n    options\n  ) {\n    const url = new URL(`check/${cid}/`, endpoint)\n    await rateLimiter()\n    const response = await fetch(url.toString(), {\n      signal: options && options.signal,\n    })\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited')\n    }\n    const result = await response.json()\n\n    if (result.ok) {\n      return {\n        cid: result.value.cid,\n        deals: decodeDeals(result.value.deals),\n        pin: result.value.pin,\n      }\n    } else {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * Removes stored content by its CID from this account. Please note that\n   * even if content is removed from the service other nodes that have\n   * replicated it might still continue providing it.\n   *\n   * @param {Service} service\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<void>}\n   */\n  static async delete(\n    { endpoint, rateLimiter = globalRateLimiter, ...token },\n    cid,\n    options\n  ) {\n    const url = new URL(`${cid}/`, endpoint)\n    await rateLimiter()\n    const response = await fetch(url.toString(), {\n      method: 'DELETE',\n      headers: NFTStorage.auth(token),\n      signal: options && options.signal,\n    })\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited')\n    }\n    const result = await response.json()\n    if (!result.ok) {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * Encodes the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in ERC-1155 to a\n   * CAR file. The `token.image` must be either a `File` or a `Blob` instance,\n   * which will be stored and the corresponding content address URL will be\n   * saved in the metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @example\n   * ```js\n   * const { token, car } = await NFTStorage.encodeNFT({\n   *   name: 'nft.storage store test',\n   *   description: 'Test ERC-1155 compatible metadata.',\n   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),\n   *   properties: {\n   *     custom: 'Custom data can appear here, files are auto uploaded.',\n   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),\n   *   }\n   * })\n   *\n   * console.log('IPFS URL for the metadata:', token.url)\n   * console.log('metadata.json contents:\\n', token.data)\n   * console.log('metadata.json with IPFS gateway URLs:\\n', token.embed())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {T} input\n   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: CarReader }>}\n   */\n  static async encodeNFT(input) {\n    validateERC1155(input)\n    return Token.Token.encode(input)\n  }\n\n  /**\n   * Encodes a single file to a CAR file and also returns its root CID.\n   *\n   * @example\n   * ```js\n   * const content = new Blob(['hello world'])\n   * const { cid, car } = await NFTStorage.encodeBlob(content)\n   *\n   * // Root CID of the file\n   * console.log(cid.toString())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @param {Blob} blob\n   * @param {object} [options]\n   * @param {BlockstoreI} [options.blockstore]\n   * @returns {Promise<{ cid: CID, car: CarReader }>}\n   */\n  static async encodeBlob(blob, { blockstore } = {}) {\n    if (blob.size === 0) {\n      throw new Error('Content size is 0, make sure to provide some content')\n    }\n    return packCar([toImportCandidate('blob', blob)], {\n      blockstore,\n      wrapWithDirectory: false,\n    })\n  }\n\n  /**\n   * Encodes a directory of files to a CAR file and also returns the root CID.\n   * Provided files **MUST** be within the same directory, otherwise error is\n   * raised e.g. `foo/bar.png`, `foo/bla/baz.json` is ok but `foo/bar.png`,\n   * `bla/baz.json` is not.\n   *\n   * @example\n   * ```js\n   * const { cid, car } = await NFTStorage.encodeDirectory([\n   *   new File(['hello world'], 'hello.txt'),\n   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')\n   * ])\n   *\n   * // Root CID of the directory\n   * console.log(cid.toString())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @param {FilesSource} files\n   * @param {object} [options]\n   * @param {BlockstoreI} [options.blockstore]\n   * @returns {Promise<{ cid: CID, car: CarReader }>}\n   */\n  static async encodeDirectory(files, { blockstore } = {}) {\n    let size = 0\n    const input = pipe(files, async function* (files) {\n      for await (const file of files) {\n        yield toImportCandidate(file.name, file)\n        size += file.size\n      }\n    })\n    const packed = await packCar(input, {\n      blockstore,\n      wrapWithDirectory: true,\n    })\n    if (size === 0) {\n      throw new Error(\n        'Total size of files should exceed 0, make sure to provide some content'\n      )\n    }\n    return packed\n  }\n\n  // Just a sugar so you don't have to pass around endpoint and token around.\n\n  /**\n   * Stores a single file and returns the corresponding Content Identifier (CID).\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File). Note\n   * that no file name or file metadata is retained.\n   *\n   * @example\n   * ```js\n   * const content = new Blob(['hello world'])\n   * const cid = await client.storeBlob(content)\n   * cid //> 'zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9'\n   * ```\n   *\n   * @param {Blob} blob\n   * @param {RequestOptions} [options]\n   */\n  storeBlob(blob, options) {\n    return NFTStorage.storeBlob(this, blob, options)\n  }\n\n  /**\n   * Stores files encoded as a single [Content Addressed Archive\n   * (CAR)](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md).\n   *\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File).\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * See the [`ipfs-car` docs](https://www.npmjs.com/package/ipfs-car) for more\n   * details on packing a CAR file.\n   *\n   * @example\n   * ```js\n   * import { pack } from 'ipfs-car/pack'\n   * import { CarReader } from '@ipld/car'\n   * const { out, root } = await pack({\n   *  input: fs.createReadStream('pinpie.pdf')\n   * })\n   * const expectedCid = root.toString()\n   * const carReader = await CarReader.fromIterable(out)\n   * const cid = await storage.storeCar(carReader)\n   * console.assert(cid === expectedCid)\n   * ```\n   *\n   * @example\n   * ```\n   * import { packToBlob } from 'ipfs-car/pack/blob'\n   * const data = 'Hello world'\n   * const { root, car } = await packToBlob({ input: [new TextEncoder().encode(data)] })\n   * const expectedCid = root.toString()\n   * const cid = await client.storeCar(car)\n   * console.assert(cid === expectedCid)\n   * ```\n   * @param {Blob|CarReader} car\n   * @param {import('./lib/interface.js').CarStorerOptions} [options]\n   */\n  storeCar(car, options) {\n    return NFTStorage.storeCar(this, car, options)\n  }\n\n  /**\n   * Stores a directory of files and returns a CID for the directory.\n   *\n   * @example\n   * ```js\n   * const cid = await client.storeDirectory([\n   *   new File(['hello world'], 'hello.txt'),\n   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')\n   * ])\n   * cid //>\n   * ```\n   *\n   * Argument can be a [FileList](https://developer.mozilla.org/en-US/docs/Web/API/FileList)\n   * instance as well, in which case directory structure will be retained.\n   *\n   * @param {FilesSource} files\n   * @param {RequestOptions} [options]\n   */\n  storeDirectory(files, options) {\n    return NFTStorage.storeDirectory(this, files, options)\n  }\n\n  /**\n   * Returns current status of the stored NFT by its CID. Note the NFT must\n   * have previously been stored by this account.\n   *\n   * @example\n   * ```js\n   * const status = await client.status('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   */\n  status(cid, options) {\n    return NFTStorage.status(this, cid, options)\n  }\n\n  /**\n   * Removes stored content by its CID from the service.\n   *\n   * > Please note that even if content is removed from the service other nodes\n   * that have replicated it might still continue providing it.\n   *\n   * @example\n   * ```js\n   * await client.delete('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   */\n  delete(cid, options) {\n    return NFTStorage.delete(this, cid, options)\n  }\n\n  /**\n   * Check if a CID of an NFT is being stored by nft.storage. Throws if the NFT\n   * was not found.\n   *\n   * @example\n   * ```js\n   * const status = await client.check('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   */\n  check(cid, options) {\n    return NFTStorage.check(this, cid, options)\n  }\n\n  /**\n   * Stores the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in\n   * [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155#metadata). The\n   * `token.image` must be either a `File` or a `Blob` instance, which will be\n   * stored and the corresponding content address URL will be saved in the\n   * metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @example\n   * ```js\n   * const metadata = await client.store({\n   *   name: 'nft.storage store test',\n   *   description: 'Test ERC-1155 compatible metadata.',\n   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),\n   *   properties: {\n   *     custom: 'Custom data can appear here, files are auto uploaded.',\n   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),\n   *   }\n   * })\n   *\n   * console.log('IPFS URL for the metadata:', metadata.url)\n   * console.log('metadata.json contents:\\n', metadata.data)\n   * console.log('metadata.json with IPFS gateway URLs:\\n', metadata.embed())\n   * ```\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {T} token\n   * @param {RequestOptions} [options]\n   */\n  store(token, options) {\n    return NFTStorage.store(this, token, options)\n  }\n}\n\n/**\n * Cast an iterable to an asyncIterable\n * @template T\n * @param {Iterable<T>} iterable\n * @returns {AsyncIterable<T>}\n */\nexport function toAsyncIterable(iterable) {\n  return (async function* () {\n    for (const item of iterable) {\n      yield item\n    }\n  })()\n}\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @param {T} metadata\n */\nconst validateERC1155 = ({ name, description, image, decimals }) => {\n  // Just validate that expected fields are present\n  if (typeof name !== 'string') {\n    throw new TypeError(\n      'string property `name` identifying the asset is required'\n    )\n  }\n  if (typeof description !== 'string') {\n    throw new TypeError(\n      'string property `description` describing asset is required'\n    )\n  }\n  if (!(image instanceof Blob)) {\n    throw new TypeError('property `image` must be a Blob or File object')\n  } else if (!image.type.startsWith('image/')) {\n    console.warn(`According to ERC721 Metadata JSON Schema 'image' must have 'image/*' mime type.\n\nFor better interoperability we would highly recommend storing content with different mime type under 'properties' namespace e.g. \\`properties: { video: file }\\` and using 'image' field for storing a preview image for it instead.\n\nFor more context please see ERC-721 specification https://eips.ethereum.org/EIPS/eip-721`)\n  }\n\n  if (typeof decimals !== 'undefined' && typeof decimals !== 'number') {\n    throw new TypeError('property `decimals` must be an integer value')\n  }\n}\n\n/**\n * @param {import('ipfs-car/pack').ImportCandidateStream|Array<{ path: string, content: import('./platform.js').ReadableStream }>} input\n * @param {object} [options]\n * @param {BlockstoreI} [options.blockstore]\n * @param {boolean} [options.wrapWithDirectory]\n */\nconst packCar = async (input, { blockstore, wrapWithDirectory } = {}) => {\n  /* c8 ignore next 1 */\n  blockstore = blockstore || new Blockstore()\n  const { root: cid } = await pack({ input, blockstore, wrapWithDirectory })\n  const car = new BlockstoreCarReader(1, [cid], blockstore)\n  return { cid, car }\n}\n\n/**\n * @param {Deal[]} deals\n * @returns {Deal[]}\n */\nconst decodeDeals = (deals) =>\n  deals.map((deal) => {\n    const { dealActivation, dealExpiration, lastChanged } = {\n      dealExpiration: null,\n      dealActivation: null,\n      ...deal,\n    }\n\n    return {\n      ...deal,\n      lastChanged: new Date(lastChanged),\n      ...(dealActivation && { dealActivation: new Date(dealActivation) }),\n      ...(dealExpiration && { dealExpiration: new Date(dealExpiration) }),\n    }\n  })\n\n/**\n * @param {Pin} pin\n * @returns {Pin}\n */\nconst decodePin = (pin) => ({ ...pin, created: new Date(pin.created) })\n\n/**\n * Convert the passed blob to an \"import candidate\" - an object suitable for\n * passing to the ipfs-unixfs-importer. Note: content is an accessor so that\n * the stream is created only when needed.\n *\n * @param {string} path\n * @param {Pick<Blob, 'stream'>|{ stream: () => AsyncIterable<Uint8Array> }} blob\n * @returns {import('ipfs-core-types/src/utils.js').ImportCandidate}\n */\nfunction toImportCandidate(path, blob) {\n  /** @type {AsyncIterable<Uint8Array>} */\n  let stream\n  return {\n    path,\n    get content() {\n      stream = stream || blob.stream()\n      return stream\n    },\n  }\n}\n\nexport { NFTStorage, File, Blob, FormData, toGatewayURL, Token }\n"],"mappings":"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E,iBAAiB,EAAE;IACrB,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,aAAajB,eAAeA,CAACkB,KAAK,EAAE;IAAElE;EAAW,CAAC,GAAG,CAAC,CAAC,EAAE;IACvD,IAAI2C,IAAI,GAAG,CAAC;IACZ,MAAMiB,KAAK,GAAGnF,IAAI,CAACyF,KAAK,EAAE,iBAAiBA,KAAK,EAAE;MAChD,WAAW,MAAMC,IAAI,IAAID,KAAK,EAAE;QAC9B,MAAMF,iBAAiB,CAACG,IAAI,CAACC,IAAI,EAAED,IAAI,CAAC;QACxCxB,IAAI,IAAIwB,IAAI,CAACxB,IAAI;MACnB;IACF,CAAC,CAAC;IACF,MAAM0B,MAAM,GAAG,MAAMN,OAAO,CAACH,KAAK,EAAE;MAClC5D,UAAU;MACViE,iBAAiB,EAAE;IACrB,CAAC,CAAC;IACF,IAAItB,IAAI,KAAK,CAAC,EAAE;MACd,MAAM,IAAIjD,KAAK,CACb,wEACF,CAAC;IACH;IACA,OAAO2E,MAAM;EACf;;EAEA;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEzE,SAASA,CAACE,IAAI,EAAEC,OAAO,EAAE;IACvB,OAAOb,UAAU,CAACU,SAAS,CAAC,IAAI,EAAEE,IAAI,EAAEC,OAAO,CAAC;EAClD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEM,QAAQA,CAACF,GAAG,EAAEJ,OAAO,EAAE;IACrB,OAAOb,UAAU,CAACmB,QAAQ,CAAC,IAAI,EAAEF,GAAG,EAAEJ,OAAO,CAAC;EAChD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE+C,cAAcA,CAACoB,KAAK,EAAEnE,OAAO,EAAE;IAC7B,OAAOb,UAAU,CAAC4D,cAAc,CAAC,IAAI,EAAEoB,KAAK,EAAEnE,OAAO,CAAC;EACxD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEoC,MAAMA,CAACjC,GAAG,EAAEH,OAAO,EAAE;IACnB,OAAOb,UAAU,CAACiD,MAAM,CAAC,IAAI,EAAEjC,GAAG,EAAEH,OAAO,CAAC;EAC9C;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE4D,MAAMA,CAACzD,GAAG,EAAEH,OAAO,EAAE;IACnB,OAAOb,UAAU,CAACyE,MAAM,CAAC,IAAI,EAAEzD,GAAG,EAAEH,OAAO,CAAC;EAC9C;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE2D,KAAKA,CAACxD,GAAG,EAAEH,OAAO,EAAE;IAClB,OAAOb,UAAU,CAACwE,KAAK,CAAC,IAAI,EAAExD,GAAG,EAAEH,OAAO,CAAC;EAC7C;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEkD,KAAKA,CAAC7D,KAAK,EAAEW,OAAO,EAAE;IACpB,OAAOb,UAAU,CAAC+D,KAAK,CAAC,IAAI,EAAE7D,KAAK,EAAEW,OAAO,CAAC;EAC/C;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASuE,eAAeA,CAACC,QAAQ,EAAE;EACxC,OAAQ,mBAAmB;IACzB,KAAK,MAAMC,IAAI,IAAID,QAAQ,EAAE;MAC3B,MAAMC,IAAI;IACZ;EACF,CAAC,CAAE,CAAC;AACN;;AAEA;AACA;AACA;AACA;AACA,MAAMX,eAAe,GAAGA,CAAC;EAAEO,IAAI;EAAEK,WAAW;EAAEC,KAAK;EAAEC;AAAS,CAAC,KAAK;EAClE;EACA,IAAI,OAAOP,IAAI,KAAK,QAAQ,EAAE;IAC5B,MAAM,IAAIQ,SAAS,CACjB,0DACF,CAAC;EACH;EACA,IAAI,OAAOH,WAAW,KAAK,QAAQ,EAAE;IACnC,MAAM,IAAIG,SAAS,CACjB,4DACF,CAAC;EACH;EACA,IAAI,EAAEF,KAAK,YAAYtG,IAAI,CAAC,EAAE;IAC5B,MAAM,IAAIwG,SAAS,CAAC,gDAAgD,CAAC;EACvE,CAAC,MAAM,IAAI,CAACF,KAAK,CAACnD,IAAI,CAACsD,UAAU,CAAC,QAAQ,CAAC,EAAE;IAC3CC,OAAO,CAACC,IAAI,CAAE;AAClB;AACA;AACA;AACA,yFAAyF,CAAC;EACxF;EAEA,IAAI,OAAOJ,QAAQ,KAAK,WAAW,IAAI,OAAOA,QAAQ,KAAK,QAAQ,EAAE;IACnE,MAAM,IAAIC,SAAS,CAAC,8CAA8C,CAAC;EACrE;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMb,OAAO,GAAG,MAAAA,CAAOH,KAAK,EAAE;EAAE5D,UAAU;EAAEiE;AAAkB,CAAC,GAAG,CAAC,CAAC,KAAK;EACvE;EACAjE,UAAU,GAAGA,UAAU,IAAI,IAAI1B,UAAU,CAAC,CAAC;EAC3C,MAAM;IAAEsE,IAAI,EAAE1C;EAAI,CAAC,GAAG,MAAMpC,IAAI,CAAC;IAAE8F,KAAK;IAAE5D,UAAU;IAAEiE;EAAkB,CAAC,CAAC;EAC1E,MAAM9D,GAAG,GAAG,IAAI3B,mBAAmB,CAAC,CAAC,EAAE,CAAC0B,GAAG,CAAC,EAAEF,UAAU,CAAC;EACzD,OAAO;IAAEE,GAAG;IAAEC;EAAI,CAAC;AACrB,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMkD,WAAW,GAAID,KAAK,IACxBA,KAAK,CAAC4B,GAAG,CAAEC,IAAI,IAAK;EAClB,MAAM;IAAEC,cAAc;IAAEC,cAAc;IAAEC;EAAY,CAAC,GAAG;IACtDD,cAAc,EAAE,IAAI;IACpBD,cAAc,EAAE,IAAI;IACpB,GAAGD;EACL,CAAC;EAED,OAAO;IACL,GAAGA,IAAI;IACPG,WAAW,EAAE,IAAI3B,IAAI,CAAC2B,WAAW,CAAC;IAClC,IAAIF,cAAc,IAAI;MAAEA,cAAc,EAAE,IAAIzB,IAAI,CAACyB,cAAc;IAAE,CAAC,CAAC;IACnE,IAAIC,cAAc,IAAI;MAAEA,cAAc,EAAE,IAAI1B,IAAI,CAAC0B,cAAc;IAAE,CAAC;EACpE,CAAC;AACH,CAAC,CAAC;;AAEJ;AACA;AACA;AACA;AACA,MAAM5B,SAAS,GAAID,GAAG,KAAM;EAAE,GAAGA,GAAG;EAAEE,OAAO,EAAE,IAAIC,IAAI,CAACH,GAAG,CAACE,OAAO;AAAE,CAAC,CAAC;;AAEvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASQ,iBAAiBA,CAACqB,IAAI,EAAEvF,IAAI,EAAE;EACrC;EACA,IAAIwF,MAAM;EACV,OAAO;IACLD,IAAI;IACJ,IAAIE,OAAOA,CAAA,EAAG;MACZD,MAAM,GAAGA,MAAM,IAAIxF,IAAI,CAACwF,MAAM,CAAC,CAAC;MAChC,OAAOA,MAAM;IACf;EACF,CAAC;AACH;AAEA,SAASpG,UAAU,EAAEf,IAAI,EAAEC,IAAI,EAAEC,QAAQ,EAAEE,YAAY,EAAEN,KAAK"},"metadata":{},"sourceType":"module","externalDependencies":[]}